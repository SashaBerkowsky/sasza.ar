+++
title="tools"
path="tools"
+++
starting with my OS, i used to run [ubuntu](https://ubuntu.com/) when i first learned how to program. i’ve always liked playing around with the desktop environment and customize everything until it looks exactly as i want it to. i also enjoyed giving new life to my old computers by installing a lightweight, fast operating system (specially compared to windows).

after a while, however, i started to feel the need to run the latest version of different programs, so i tried some _rolling release distributions_. that’s how i ran into [arch linux](https://archlinux.org/). at the time, the [archinstall script](https://wiki.archlinux.org/title/Archinstall) didn’t exist, so installing it manually sparked my interest in how operating systems actually work and how they are built.

currently, i’m still running arch mainly because of the _rolling release updates_, the [aur](https://wiki.archlinux.org/title/Arch_User_Repository), and the flexibility arch gives me to tailor every element of my OS exactly the way that i want through [theming and ricing](https://jie-fang.github.io/blog/basics-of-ricing).

{{ figure(src="/img/setup.png", caption="my current setup running arch + hyprland + swaync") }}

that said, i’ve never personally run into any of the common issues people on the internet usually complain with _arch_. honestly, the day i do, i’ll probably follow [linus torvalds](https://es.wikipedia.org/wiki/Linus_Torvalds) and jump ship to [fedora](https://www.fedoraproject.org/es/)

# programs

my personal criteria when choosing the tools that i use for work (and other things in life) tend to go hand in hand with the [unix philosophy](http://www.catb.org/~esr/writings/taoup/html/ch01s06.html). to put it in a few words, these are design principles for software to be:

- programs that do one thing and do it well
- programs designed to work together
- programs that handle text streams
